The MessageQueue class provides an event driven framework for processing messages.

Timers
    Timers are created with create_timer(). You can create one shot timers or repeating timers.
    You can cancel and pause timers and well as reset a timer.

    When a timer fires, a TIMER_EVENT is posted to the event queue

Digital read
    The digitalRead() sets up the reading of a digital pin. You can also provide 
    a timeout for debouncing the input.

    Only when the state of the pin changes from HIGH to LOW or LOW to HIGH will a VALUE_EVENT
    be posted to the queue.

Analog read
    The analogRead() call sets up the reading of an analog pin. A VALUE_EVENT will be posted 
    either on every call to get_message() or when a specified number of microseconds has elapsed.

    Each read generates a VALUE_EVENT.

Pulse output
    When toggleing a output pin for a specified duration, the canonical method to to write HIGH,
    delay, then write low. The delay will prevent any other work from being performed. Using
    the MessageQueue allows events to still be processed even during lengthy pulse durations.

State values
    State values are a mechanism to define a variable that will generate an event only when the value
    actually changes.


================================================================================
Examples:

MessageQueue mq(8, 1, 1, 1, 1);

static const int MY_TIMER_ID = 0;
statuc const int MY_DIGITAL_ID = 0;
static const int MY_ANALOG_ID = 1;
static const int MY_STATE_ID = 2;

void setup()
{
    // Create a one second repeating timer
    mq.create_timer(MY_TIMER_ID, 1000, true);

    // Read pin 4 with a 500uS debounce time
    mq.digitalRead(MY_DIGITAL_ID, 4, HIGH, 500);
    pinMode(4, INPUT);

    // Read analog pin A0 every millisecond
    mw.analogRead(MY_ANALOG_ID, A0, 1000);
}

void loop()
{
    int msg, arg1;
    unsigned long arg2;

    mq.get_message(msg, arg1, arg2);
    switch(msg)
    {
    case TIMER_EVENT:
        if (arg1 == MY_TIMER_ID)
        {
            Serial.println("Timer fired!");
        }
        break;
    case VALUE_EVENT:
        if (arg1 == MY_DIGITAL_ID)
        {
            Serial.print("Digital pin value: ");
            Serial.print(arg2);
        }  
        if (arg1 == MY_ANALOG_ID)
        {
            Serial.print("Analog pin value: ");
            Serial.print(arg2);
        }
        break;
    case IDLE_EVENT:
        break;
    }
}
